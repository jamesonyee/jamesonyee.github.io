<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet" />
    <link
        href="https://fonts.googleapis.com/css2?family=PT+Sans:ital,wght@0,400;0,700;1,400;1,700&family=Roboto+Slab:wght@100..900&display=swap"
        rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    <link rel="stylesheet" href="styles/style.css" />
    <link rel="stylesheet" href="styles/homepage.css" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.css" />

    <script src="/js/sidebar.js"></script>

    <script>
        hljs.highlightAll();
    </script>

    <title>Jameson Yee - Roblox</title>
</head>

<body>
    <header>
        <i class="fa fa-bars" id="hamburger" aria-hidden="true"></i>
        <nav id="sidebar">
            <i class="fa fa-times" id="close-button" aria-hidden="true"></i>
            <br />

            <details>
                <summary>Home</summary>
                <ul>
                    <li><a href="index.html#introduction">Introduction</a></li>
                    <li><a href="index.html#skills">Interests</a></li>
                    <li><a href="index.html#edu">Education</a></li>
                    <li><a href="index.html#exp">Experience</a></li>
                    <li><a href="index.html#Resume">Resume</a></li>
                </ul>
            </details>

            <details>
                <summary>Projects</summary>
                <ul>
                    <li><a href="/waves.html">Wave Simulation</a></li>
                    <li><a href="/flightsim.html">Flight Simulator</a></li>
                    <li><a href="/ballquest.html"> BallQuest AR</a></li>
                    <li><a href="/MLviewer.html"> ML2 Model viewer</a></li>
                    <li><a href="/models.html"> 3D Models </a></li>
                </ul>
            </details>
        </nav>
    </header>
    <div id="content-wrapper">
        <div id="writeup">
        <h1>Twin Atlas Application </h1>

        <p>I specialize in real-time interactive experiences, focusing on gameplay prototyping and programming. My primary
        tools are Unreal Engine 5, C++, and Blueprints, which I use to develop mechanics, character systems, and
        interactive environments for both virtual reality and traditional platforms.
    
        While my core experience is in Unreal Engine 5, these demos highlight the versatility and adaptability of my
        skills. In Roblox Studio, I’ve built working prototypes using Lua—such as a wave based zombie survival game, and
        an endless runner with procedurally generated obstacles and coin placement.
        </p>
        
            <h1>Wave-Based Survival Game Demo </h1>
            <iframe 
                id="video" 
                src="https://www.youtube.com/embed/sJWHWXioG4o?si=qcnV35zahwDTR2CP" 
                title="YouTube video player" 
                frameborder="0" 
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            <p class="caption">Map made by <a href="https://create.roblox.com/store/asset/8134919544/zombie-map-two">@samigejmer123 </a>
           <h2>Features</h2>

           <h3>1. Wave-Based Spawning with Zombie Variety</h3>
        <p>
            Each round, zombies are spawned from a configurable pool of enemy types—allowing the system to introduce new zombie variants as the game progresses.
            The number of zombies per wave increases over time, and each zombie’s health scales with the current wave’s difficulty multiplier.
            This ensures that rounds become progressively more challenging, with both stronger enemies and higher enemy counts.
        </p>
        <details>
            <summary>Show Lua Code</summary>
            <pre><code class="language-lua">function ZombieWaveManager:NextWave()
            self.CurrentWave += 1
            self.ZombiesKilled = 0
            self.ZombiesAlive = 0

            -- Calculate zombie count and health scaling
            local zombiesToSpawn = math.floor(WAVE_CONFIG.InitialZombies +
                WAVE_CONFIG.ZombieIncrement * (self.CurrentWave - 1))
            local healthMultiplier = WAVE_CONFIG.DifficultyIncrease ^ (self.CurrentWave - 1)

            -- Spawn from a pool of possible zombie types
            for i = 1, zombiesToSpawn do
                task.spawn(function()
                    self:SpawnZombie(healthMultiplier) -- applies scaling health
                end)
                task.wait(0.5)
            end
        end

        function ZombieWaveManager:SpawnZombie(healthMultiplier)
            if not self.Active then return end

            -- Pick a zombie type from the pool
            local zombieTypes = { "Zombie" } -- More types can be added here
            local chosenType = zombieTypes[math.random(1, #zombieTypes)]
            local template = self.ZombiePool:FindFirstChild(chosenType)
            if not template then return end

            local zombie = template:Clone()
            local humanoid = zombie:FindFirstChildOfClass("Humanoid")
            if not humanoid then return end

            -- Apply health scaling
            humanoid.MaxHealth = humanoid.MaxHealth * healthMultiplier
            humanoid.Health = humanoid.MaxHealth

            -- Mark as zombie
            local isZombie = Instance.new("BoolValue")
            isZombie.Name = "IsZombie"
            isZombie.Value = true
            isZombie.Parent = zombie

            -- Position zombie near a random player
            local players = game.Players:GetPlayers()
            if #players > 0 then
                local basePos = players[math.random(1, #players)].Character:GetPivot().Position
                local spawnPos = basePos + Vector3.new(
                    math.random(-WAVE_CONFIG.SpawnRadius, WAVE_CONFIG.SpawnRadius),
                    0,
                    math.random(-WAVE_CONFIG.SpawnRadius, WAVE_CONFIG.SpawnRadius)
                )
                zombie:PivotTo(CFrame.new(spawnPos))
            end

            zombie.Parent = workspace
            self.ZombiesAlive += 1
        end</code></pre>
        </details>


            <h3>2. Precision Shooting and Damage System</h3>
            <p>
                Players use hitscan shooting to damage zombies. The shooting system uses raycasting for instant hit detection, spawns visual bullet trails,
                and notifies the server to apply damage.
            </p>
            <details>
                <summary>Show Lua Code</summary>
                <pre><code class="language-lua">function shoot()
                local origin = camera.CFrame.Position
                local direction = camera.CFrame.LookVector * 500
                local raycastParams = RaycastParams.new()
                raycastParams.FilterDescendantsInstances = {character, ViewModel}
                raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                raycastParams.IgnoreWater = true

                local result = workspace:Raycast(origin, direction, raycastParams)

                if result then
                    local hitPart = result.Instance
                    local hitHumanoid = hitPart.Parent:FindFirstChildOfClass("Humanoid")
                    if hitHumanoid and hitHumanoid.Parent:FindFirstChild("IsZombie") then
                        local damageEvent = game.ReplicatedStorage:FindFirstChild("ZombieWave_ZombieKilled")
                        if damageEvent then
                            damageEvent:FireServer(hitHumanoid.Parent)
                        end
                    end
                end
            end</code></pre>
            </details>

            <h1>Infinite Runner Demo</h1>

            <iframe id="video" src="https://www.youtube.com/embed/hRZ-ctacfSE?si=cn98M9-IFItLe8GU"
                title="YouTube video player" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            <h2>Features</h2>
            <h3>1. Procedural Generation</h3>
            <p>Coins and obstacles are procedurally generated, by the server, ahead of the player across three lanes allowing
                players to
                make calculated risks to collect coins. Spawning adapts to the player's position and ensures dynamic
                and
                unique coin placement each round.</p>
            <details>
                <summary>Show Lua Code</summary>
                <pre><code class="language-lua">-- Get a random obstacle prefab
local function getRandomObstacle()
	local obstacles = obstacleFolder:GetChildren()
	return obstacles[math.random(1, #obstacles)]:Clone()
end

-- Spawn obstacle at a random lane
local function spawnObstacle(playerPositionZ)
	local laneIndex = math.random(1, #lanes)
	local laneX = lanes[laneIndex]

	local obstacle = getRandomObstacle()
	obstacle.Parent = Workspace
	obstacle.Anchored = true
	obstacle.CanCollide = true
	
	local baseY = 0
    local obstacleHeight = obstacle.Size.Y
    local yPosition = baseY + (obstacleHeight / 2)

	obstacle.CFrame = CFrame.new(laneX, yPosition, playerPositionZ - spawnZDistance)
	table.insert(activeObstacles, obstacle)
end </code>
</details>
            
            </pre>
                <h3>2. Scaling Difficulty</h3>
                <p>As the game progresses, obstacles spawn more frequently and may appear in quick succession, ramping
                    up
                    the
                    challenge. The system dynamically adjusts difficulty using a multiplier over time, making each wave
                    increasingly intense without needing manual level design.</p>

                <details>
                    <summary>Show Lua Code</summary>

                    <pre><code class="language-lua">-- Update difficulty progression
timeElapsed += dt
activeMultipliers = 1 + math.min(timeElapsed / difficultyRampTime, 1) * 3
currentSpawnInterval = math.max(baseSpawnInterval / activeMultipliers, minSpawnInterval)

-- Spawning logic
lastSpawn += dt
if lastSpawn >= currentSpawnInterval then
    spawnObstacle(hrp.Position.Z)

    if activeMultipliers > 2 and math.random() < 0.3 then
        task.delay(0.15, function()
            if playerAlive and hrp and hrp.Parent then
                spawnObstacle(hrp.Position.Z)
            end
        end)
    end

    lastSpawn = 0
end</code></pre>

                </details>

        </div>
    </div>
</body>

</html>